/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package ca.uvic.seng330.ex3;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;

class ObservationTests {

    private List<Observation> unorderedList;
    private ObservationRepository observations;

    private Observation observation1;
    private Observation otherObservation1;
    private Observation observation2;
    private Observation observation3;
    private Observation observation4;

    @BeforeEach
    void initalizeData() {

        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");




        try {
            otherObservation1 = new Observation();
            otherObservation1.setObservationId(1);
            observation1 = new Observation();
            observation1.setSightingTime(format.parse("2020-10-01")); //2020-10-1
            observation1.setObservationId(1);
            observation2 = new Observation();
            observation2.setSightingTime(format.parse("2020-09-01")); //2020-9-1
            observation2.setObservationId(2);
            observation3 = new Observation();
            observation3.setSightingTime(format.parse("2020-09-05")); //2020-9-5
            observation3.setObservationId(3);
            observation4 = new Observation();
            observation4.setSightingTime(format.parse("2020-09-05")); //2020-9-5
            observation4.setObservationId(4);
        } catch (Exception e) {
            fail();
        }
        unorderedList = new ArrayList<>();
        unorderedList.add(observation1);
        unorderedList.add(observation3);
        unorderedList.add(observation2);
        unorderedList.add(observation4);

        observations = new ObservationRepository(unorderedList);

    }

    @Test
    void testObservationCompareTo(){
        int isSame = observation1.compareTo(otherObservation1);
        int ob2IsGreaterob1 = observation2.compareTo(observation1);
        int ob1IsLessob2 = observation1.compareTo(observation2);

        assertEquals(isSame, 0);
        assertTrue(ob2IsGreaterob1 > 0);
        assertTrue(ob1IsLessob2 < 0);
    }

    @Test
    void testObservationComparator(){
        Comparator<Observation> byDate = new Observation.compareByDate();

        int isSame = byDate.compare(observation1, observation2);
        int ob2IsGreaterOb1 = byDate.compare(observation2, observation1);
        int ob1IsLessOb2 = byDate.compare(observation1, observation2);

        assertEquals(isSame, 0);
        assertTrue(ob2IsGreaterOb1 > 0);
        assertTrue(ob1IsLessOb2 < 0);
    }

    @Test
    void testObservationDateComparatorTimeInsensitive(){
        Comparator<Observation> byDate = new Observation.compareByDate();
        Observation ob1 = new Observation();
        Observation ob2 = new Observation();

        long d1 = 1602325830; //2020-10-10 3:30:30am
        long d2 = 1602333030; //2020-10-10 5:30:30am

        ob1.setSightingTime(new Date(d1));
        ob2.setSightingTime(new Date(d2));

        int isSame = byDate.compare(ob1, ob2);
        assertEquals(isSame, 0);
    }



    @Test
    void sortObservationRepositoryByDate() {
        List<Observation> expectedList = new ArrayList<>();
        expectedList.add(observation2);
        expectedList.add(observation3);
        expectedList.add(observation4);
        expectedList.add(observation1);
        observations.sortByDate();
        assertEquals(expectedList, observations.getObservations());
    }

    @Test
    void sortEmptyObservationRepositoryByDate() {
        ObservationRepository observations = new ObservationRepository();
        Assertions.assertDoesNotThrow(observations::sortByDate);
    }

    @Test
    void sortObservationRepositoryById() {
        List<Observation> expectedList = new ArrayList<>();
        expectedList.add(observation1);
        expectedList.add(observation2);
        expectedList.add(observation3);
        expectedList.add(observation4);

        observations.sortById();

        assertEquals(expectedList, observations.getObservations());
        assertNotEquals(unorderedList, observations.getObservations());
    }

    @Test
    void sortEmptyObservationRepositoryById() {
        // Test for empty observations collection
        ObservationRepository observations = new ObservationRepository();
        Assertions.assertDoesNotThrow(observations::sortById);
    }

    @Test
    void searchByDate() throws ParseException {
        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");
        Date date = format.parse("2020-09-01");

        List<Observation> result = new ArrayList<>();
        try {
            result = observations.getByDate(date);
        } catch (Exception e) {
            fail();
        }

        assertEquals(1, result.size());
        assertEquals(date, result.get(0).getSightingTime());
    }

    @Test
    void searchMultipleResultsByDate() throws ParseException {
        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");
        Date date = format.parse("2020-09-05");
        List<Observation> result = new ArrayList<>();

        try {
            result = observations.getByDate(date);
        } catch (Exception e) {
            fail();
        }

        assertEquals(2, result.size());
        assertEquals(date, result.get(0).getSightingTime());
        assertEquals(date, result.get(1).getSightingTime());
    }

    @Test
    void searchByInvalidDate() {
        assertThrows(NullPointerException.class,() -> observations.getByDate(null));
    }

    @Test
    void searchByDateEmptyResult() {
        assertThrows(NoSuchElementException.class,
                () -> {
                    SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");
                    Date date = format.parse("2020-09-23");
                    List<Observation> search = observations.getByDate(date);
                });
    }

    @Test
    void searchById() {
        Observation search = null;
        long SEARCH_OBSERVATION_ID = 1;
        try {
            search = observations.getById(SEARCH_OBSERVATION_ID);
        } catch (Exception e) {
            fail();
        }
        assertEquals(SEARCH_OBSERVATION_ID, search.getObservationId());
    }

    @Test
    void searchByInvalidId() {
        assertThrows(IllegalArgumentException.class, () -> observations.getById(-1));
    }
}
